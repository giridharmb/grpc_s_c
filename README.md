### Setup

```
brew install protobuf
```

```
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
```

```
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

```
protoc --go_out=pkg --go-grpc_out=pkg proto/ping.proto
```

# Distributed gRPC Messaging Flow

This project demonstrates a distributed system where virtual machines (clients) send periodic pings to a gRPC server that runs on a Kubernetes (K8s) cluster. The server registers clients, tracks their live status using Redis, persists client data and pending messages in PostgreSQL, and delivers messages received from an external source (simulated as an Azure Event Hub) to active clients.

## Overview

The system works as follows:

1. **Client Registration & Heartbeats:**  
   - Each client (a virtual machine) sends a gRPC `SendPing` request with its IP address and a generic JSON payload.
   - The server upserts the client's record in PostgreSQL (creating or updating the `lastSeen` timestamp) and sets an active key in Redis with a 5-second TTL.
   - Clients send these pings every 5 seconds.

2. **Message Delivery:**  
   - The server checks for any pending messages stored in PostgreSQL when a client pings.
   - If pending messages exist and the client is active (determined via Redis), the server publishes these messages using Redis Pub/Sub.
   - Clients use a streaming RPC (`ListenForMessages`) to subscribe to their dedicated Redis channel and receive messages immediately.

3. **External Event Handling:**  
   - An external data source (e.g., Azure Event Hub) sends a JSON message with a target client IP.
   - The server checks Redis to verify if the target client is active:
     - **Active:** The server publishes the message on the client's Redis channel.
     - **Inactive:** The server stores the message as pending in PostgreSQL (for a maximum of 1 hour).
   - When an inactive client comes back online, its next ping triggers delivery of any pending messages.

4. **Background Tasks:**  
   - A background goroutine cleans up stale client records from PostgreSQL every 5 seconds.
   - Another background process periodically deletes pending messages older than 1 hour from the database.

### Flow

[Flow Diagram](flow.mermaid)

## Directory Structure

```
grpc_s_c/
├── cmd/
│   ├── server/
│   │   └── main.go         # Contains your server (server.go) code.
│   └── client/
│       └── main.go         # Contains your client (client.go) code.
├── proto/
│   └── ping.proto          # Your proto definition file.
├── pkg/
│   └── pingpb/             # Package for generated code from ping.proto.
│         ├── ping.pb.go         # Generated by protoc.
│         └── ping_grpc.pb.go    # Generated by protoc.
├── go.mod
└── go.sum
```

- **cmd/server/main.go:** Contains the gRPC server code with PostgreSQL, Redis, and external event processing.
- **cmd/client/main.go:** Contains the gRPC client code that pings the server and listens for messages.
- **proto/ping.proto:** Defines the gRPC service and messages.
- **pkg/pingpb:** Contains the generated Go code from the proto file.

## Installation & Setup

### Prerequisites

- Go 1.16+
- PostgreSQL instance (local or hosted)
- Redis instance (local or hosted)
- Homebrew (for macOS users) to install Protocol Buffers

### Installing Protocol Buffers

Use Homebrew to install `protoc`:

```bash
brew install protobuf
```

### How the System Works

1.	Client Registration and Heartbeat:
    •	Ping RPC: Clients call SendPing with their IP and JSON payload.
    •	Database Update: The server upserts the client record in PostgreSQL.
    •	Redis Active Status: The server sets a Redis key (e.g., active:192.168.1.100) with a 5-second TTL to indicate the client is alive.
    •	Pending Message Check: On ping, the server queries PostgreSQL for pending messages for the client. If found, they are published via Redis Pub/Sub and marked as delivered.
2.	Message Delivery via Streaming:
    •	Listening RPC: Clients open the ListenForMessages streaming RPC.
    •	Redis Pub/Sub: The server subscribes the client to its specific Redis channel (e.g., client:192.168.1.100:messages), pushing any messages published to that channel.
3.	Handling External Events:
    •	Event Processing: When an external event arrives, the server checks Redis to see if the target client is active.
    •	Immediate vs. Deferred Delivery:
    •	If active, the event message is published on the client’s Redis channel.
    •	If inactive, the message is stored as pending in PostgreSQL.
    •	Deferred Delivery: When an inactive client returns and sends its next ping, any pending messages are delivered immediately.
4.	Background Cleanup:
    •	Client Cleanup: The server removes client records from PostgreSQL that haven’t sent a ping within 5 seconds.
    •	Pending Message Cleanup: Periodically cleans pending messages older than 1 hour.

#### Run the server

```
cd cmd/server
go run main.go
```

#### Run the client

```
cd cmd/client
go run main.go
```